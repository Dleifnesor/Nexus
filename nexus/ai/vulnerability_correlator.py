"""
Nexus Vulnerability Correlation Engine

Advanced AI-powered vulnerability correlation system that analyzes findings
from multiple tools, identifies relationships, and provides intelligent
vulnerability assessment and prioritization.
"""

import json
import re
import time
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import logging
from collections import defaultdict
import hashlib

logger = logging.getLogger(__name__)


class VulnerabilityType(Enum):
    """Types of vulnerabilities"""
    NETWORK = "network"
    WEB_APPLICATION = "web_application"
    SYSTEM = "system"
    DATABASE = "database"
    WIRELESS = "wireless"
    SOCIAL_ENGINEERING = "social_engineering"
    PHYSICAL = "physical"
    CRYPTOGRAPHIC = "cryptographic"


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class Vulnerability:
    """Individual vulnerability finding"""
    vuln_id: str
    name: str
    description: str
    severity: SeverityLevel
    vuln_type: VulnerabilityType
    host: str
    port: Optional[int] = None
    service: Optional[str] = None
    cve_ids: List[str] = field(default_factory=list)
    cvss_score: Optional[float] = None
    tool_source: str = ""
    raw_output: str = ""
    evidence: Dict[str, Any] = field(default_factory=dict)
    discovered_at: float = field(default_factory=time.time)
    exploitable: bool = False
    exploit_difficulty: str = "unknown"  # trivial, easy, medium, hard
    
    def __post_init__(self):
        if not self.vuln_id:
            self.vuln_id = self._generate_id()
    
    def _generate_id(self) -> str:
        """Generate unique vulnerability ID"""
        content = f"{self.name}_{self.host}_{self.port}_{self.service}"
        return f"vuln_{hashlib.md5(content.encode()).hexdigest()[:12]}"


@dataclass
class VulnerabilityCluster:
    """Group of related vulnerabilities"""
    cluster_id: str
    vulnerabilities: List[Vulnerability]
    cluster_type: str  # "same_service", "same_host", "attack_chain", "similar_vuln"
    risk_score: float
    attack_complexity: str
    description: str
    recommended_actions: List[str] = field(default_factory=list)


class VulnerabilityCorrelator:
    """AI-powered vulnerability correlation engine"""
    
    def __init__(self, ai_client, config):
        self.ai_client = ai_client
        self.config = config
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.clusters: Dict[str, VulnerabilityCluster] = {}
        self.correlation_rules = self._load_correlation_rules()
        self.cve_database = self._load_cve_database()
    
    def _load_correlation_rules(self) -> Dict[str, Any]:
        """Load vulnerability correlation rules"""
        return {
            "service_correlations": {
                "apache": ["directory_traversal", "rce", "information_disclosure"],
                "nginx": ["buffer_overflow", "directory_traversal", "header_injection"],
                "mysql": ["sql_injection", "privilege_escalation", "information_disclosure"],
                "ssh": ["brute_force", "key_disclosure", "version_disclosure"],
                "ftp": ["anonymous_access", "directory_traversal", "brute_force"],
                "smb": ["null_session", "share_enumeration", "relay_attack"],
                "rdp": ["brute_force", "bluekeep", "credential_exposure"]
            },
            "attack_chains": {
                "web_to_system": [
                    ["sql_injection", "file_upload", "rce"],
                    ["xss", "csrf", "session_hijacking"],
                    ["lfi", "log_poisoning", "rce"]
                ],
                "network_to_domain": [
                    ["smb_enumeration", "credential_harvesting", "lateral_movement"],
                    ["kerberoasting", "asreproasting", "golden_ticket"]
                ],
                "privilege_escalation": [
                    ["kernel_exploit", "suid_binary", "root_access"],
                    ["service_misconfiguration", "weak_permissions", "privilege_escalation"]
                ]
            },
            "severity_modifiers": {
                "public_exploit_available": 2.0,
                "remote_exploitable": 1.5,
                "no_authentication_required": 1.8,
                "high_privilege_impact": 1.7,
                "data_exposure": 1.4,
                "service_disruption": 1.2
            }
        }
    
    def _load_cve_database(self) -> Dict[str, Any]:
        """Load CVE database for vulnerability enrichment"""
        # In a real implementation, this would load from NIST NVD or similar
        return {
            "sample_cves": {
                "CVE-2021-44228": {
                    "description": "Log4j Remote Code Execution",
                    "cvss_score": 10.0,
                    "severity": "critical",
                    "exploitable": True,
                    "public_exploit": True
                }
            }
        }
    
    async def add_vulnerability_from_tool_output(self, tool_name: str, tool_output: Dict[str, Any], 
                                               target_info: Dict[str, Any]) -> List[Vulnerability]:
        """Extract and add vulnerabilities from tool output"""
        vulnerabilities = []
        
        # Tool-specific vulnerability extraction
        if tool_name.lower() == "nmap":
            vulnerabilities.extend(self._extract_nmap_vulnerabilities(tool_output, target_info))
        elif tool_name.lower() == "nikto":
            vulnerabilities.extend(self._extract_nikto_vulnerabilities(tool_output, target_info))
        elif tool_name.lower() == "sqlmap":
            vulnerabilities.extend(self._extract_sqlmap_vulnerabilities(tool_output, target_info))
        elif tool_name.lower() == "nuclei":
            vulnerabilities.extend(self._extract_nuclei_vulnerabilities(tool_output, target_info))
        else:
            # Generic vulnerability extraction using AI
            vulnerabilities.extend(await self._ai_extract_vulnerabilities(tool_name, tool_output, target_info))
        
        # Add vulnerabilities to database
        for vuln in vulnerabilities:
            self.vulnerabilities[vuln.vuln_id] = vuln
            logger.info(f"Added vulnerability: {vuln.name} on {vuln.host}")
        
        # Trigger correlation analysis
        if vulnerabilities:
            await self._correlate_vulnerabilities()
        
        return vulnerabilities
    
    def _extract_nmap_vulnerabilities(self, nmap_output: Dict[str, Any], target_info: Dict[str, Any]) -> List[Vulnerability]:
        """Extract vulnerabilities from Nmap output"""
        vulnerabilities = []
        
        for host_data in nmap_output.get("hosts", []):
            host = host_data.get("host", "unknown")
            
            for port_data in host_data.get("ports", []):
                if port_data.get("state") == "open":
                    port = port_data.get("port")
                    service = port_data.get("service", "unknown")
                    version = port_data.get("version", "")
                    
                    # Check for known vulnerable services
                    vuln_checks = self._check_service_vulnerabilities(service, version, host, port)
                    vulnerabilities.extend(vuln_checks)
        
        return vulnerabilities
    
    def _extract_nikto_vulnerabilities(self, nikto_output: Dict[str, Any], target_info: Dict[str, Any]) -> List[Vulnerability]:
        """Extract vulnerabilities from Nikto output"""
        vulnerabilities = []
        
        # Parse Nikto findings
        findings = nikto_output.get("findings", [])
        host = target_info.get("host", "unknown")
        
        for finding in findings:
            severity = self._map_nikto_severity(finding.get("severity", "info"))
            
            vuln = Vulnerability(
                vuln_id="",
                name=finding.get("title", "Web Vulnerability"),
                description=finding.get("description", ""),
                severity=severity,
                vuln_type=VulnerabilityType.WEB_APPLICATION,
                host=host,
                port=finding.get("port", 80),
                service="http",
                tool_source="nikto",
                evidence=finding
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _extract_sqlmap_vulnerabilities(self, sqlmap_output: Dict[str, Any], target_info: Dict[str, Any]) -> List[Vulnerability]:
        """Extract vulnerabilities from SQLMap output"""
        vulnerabilities = []
        
        if sqlmap_output.get("vulnerable", False):
            injection_points = sqlmap_output.get("injection_points", [])
            host = target_info.get("host", "unknown")
            
            for injection in injection_points:
                vuln = Vulnerability(
                    vuln_id="",
                    name="SQL Injection",
                    description=f"SQL injection in parameter: {injection.get('parameter', 'unknown')}",
                    severity=SeverityLevel.HIGH,
                    vuln_type=VulnerabilityType.WEB_APPLICATION,
                    host=host,
                    port=target_info.get("port", 80),
                    service="http",
                    tool_source="sqlmap",
                    evidence=injection,
                    exploitable=True,
                    exploit_difficulty="easy"
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _extract_nuclei_vulnerabilities(self, nuclei_output: Dict[str, Any], target_info: Dict[str, Any]) -> List[Vulnerability]:
        """Extract vulnerabilities from Nuclei output"""
        vulnerabilities = []
        
        matches = nuclei_output.get("matches", [])
        
        for match in matches:
            severity = self._map_nuclei_severity(match.get("info", {}).get("severity", "info"))
            
            vuln = Vulnerability(
                vuln_id="",
                name=match.get("info", {}).get("name", "Security Issue"),
                description=match.get("info", {}).get("description", ""),
                severity=severity,
                vuln_type=self._determine_vuln_type(match),
                host=match.get("host", "unknown"),
                port=match.get("port"),
                service=match.get("service"),
                tool_source="nuclei",
                evidence=match
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _ai_extract_vulnerabilities(self, tool_name: str, tool_output: Dict[str, Any], 
                                        target_info: Dict[str, Any]) -> List[Vulnerability]:
        """Use AI to extract vulnerabilities from unknown tool output"""
        
        prompt = f"""Analyze the following {tool_name} output and extract security vulnerabilities:

TOOL OUTPUT:
{json.dumps(tool_output, indent=2)}

TARGET INFO:
{json.dumps(target_info, indent=2)}

Extract vulnerabilities and return as JSON array with this format:
[
  {{
    "name": "vulnerability name",
    "description": "detailed description",
    "severity": "critical|high|medium|low|info",
    "type": "network|web_application|system|database|wireless",
    "host": "target host",
    "port": port_number_or_null,
    "service": "service name or null",
    "exploitable": true_or_false,
    "exploit_difficulty": "trivial|easy|medium|hard",
    "evidence": {{"key": "value"}}
  }}
]

Only return valid JSON, no additional text."""

        try:
            from nexus.ai.ollama_client import GenerationRequest
            request = GenerationRequest(
                model=self.config.ai.model,
                prompt=prompt,
                system="You are a cybersecurity expert analyzing tool output for vulnerabilities.",
                temperature=0.3
            )
            
            response = await self.ai_client.generate(request)
            
            # Parse AI response
            vulnerabilities_data = json.loads(response.response)
            vulnerabilities = []
            
            for vuln_data in vulnerabilities_data:
                vuln = Vulnerability(
                    vuln_id="",
                    name=vuln_data.get("name", "Unknown Vulnerability"),
                    description=vuln_data.get("description", ""),
                    severity=SeverityLevel(vuln_data.get("severity", "info")),
                    vuln_type=VulnerabilityType(vuln_data.get("type", "system")),
                    host=vuln_data.get("host", target_info.get("host", "unknown")),
                    port=vuln_data.get("port"),
                    service=vuln_data.get("service"),
                    tool_source=tool_name,
                    evidence=vuln_data.get("evidence", {}),
                    exploitable=vuln_data.get("exploitable", False),
                    exploit_difficulty=vuln_data.get("exploit_difficulty", "unknown")
                )
                vulnerabilities.append(vuln)
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"AI vulnerability extraction failed: {e}")
            return []
    
    async def _correlate_vulnerabilities(self):
        """Perform vulnerability correlation analysis"""
        
        # Clear existing clusters
        self.clusters.clear()
        
        # Group vulnerabilities by different criteria
        host_groups = self._group_by_host()
        service_groups = self._group_by_service()
        attack_chains = await self._identify_attack_chains()
        similar_vulns = self._group_similar_vulnerabilities()
        
        # Create clusters
        cluster_id = 0
        
        # Host-based clusters
        for host, vulns in host_groups.items():
            if len(vulns) > 1:
                cluster = VulnerabilityCluster(
                    cluster_id=f"host_cluster_{cluster_id}",
                    vulnerabilities=vulns,
                    cluster_type="same_host",
                    risk_score=self._calculate_cluster_risk(vulns),
                    attack_complexity=self._assess_attack_complexity(vulns),
                    description=f"Multiple vulnerabilities on host {host}"
                )
                self.clusters[cluster.cluster_id] = cluster
                cluster_id += 1
        
        # Service-based clusters
        for service, vulns in service_groups.items():
            if len(vulns) > 1:
                cluster = VulnerabilityCluster(
                    cluster_id=f"service_cluster_{cluster_id}",
                    vulnerabilities=vulns,
                    cluster_type="same_service",
                    risk_score=self._calculate_cluster_risk(vulns),
                    attack_complexity=self._assess_attack_complexity(vulns),
                    description=f"Multiple vulnerabilities in {service} service"
                )
                self.clusters[cluster.cluster_id] = cluster
                cluster_id += 1
        
        # Attack chain clusters
        for chain in attack_chains:
            if len(chain) > 1:
                cluster = VulnerabilityCluster(
                    cluster_id=f"chain_cluster_{cluster_id}",
                    vulnerabilities=chain,
                    cluster_type="attack_chain",
                    risk_score=self._calculate_cluster_risk(chain),
                    attack_complexity=self._assess_attack_complexity(chain),
                    description="Vulnerabilities forming potential attack chain"
                )
                self.clusters[cluster.cluster_id] = cluster
                cluster_id += 1
        
        logger.info(f"Created {len(self.clusters)} vulnerability clusters")
    
    def _group_by_host(self) -> Dict[str, List[Vulnerability]]:
        """Group vulnerabilities by host"""
        groups = defaultdict(list)
        for vuln in self.vulnerabilities.values():
            groups[vuln.host].append(vuln)
        return dict(groups)
    
    def _group_by_service(self) -> Dict[str, List[Vulnerability]]:
        """Group vulnerabilities by service"""
        groups = defaultdict(list)
        for vuln in self.vulnerabilities.values():
            if vuln.service:
                groups[vuln.service].append(vuln)
        return dict(groups)
    
    async def _identify_attack_chains(self) -> List[List[Vulnerability]]:
        """Identify potential attack chains using AI"""
        chains = []
        
        # Use AI to identify attack chains
        vulns_data = []
        for vuln in self.vulnerabilities.values():
            vulns_data.append({
                "id": vuln.vuln_id,
                "name": vuln.name,
                "host": vuln.host,
                "service": vuln.service,
                "type": vuln.vuln_type.value,
                "severity": vuln.severity.value,
                "exploitable": vuln.exploitable
            })
        
        prompt = f"""Analyze these vulnerabilities and identify potential attack chains:

VULNERABILITIES:
{json.dumps(vulns_data, indent=2)}

Identify sequences of vulnerabilities that could be chained together for attack progression.
Return as JSON array of chains:
[
  {{
    "chain_id": "unique_id",
    "vulnerability_ids": ["vuln_id1", "vuln_id2", "vuln_id3"],
    "description": "attack chain description",
    "attack_path": "step by step attack path"
  }}
]

Only return valid JSON."""

        try:
            from nexus.ai.ollama_client import GenerationRequest
            request = GenerationRequest(
                model=self.config.ai.model,
                prompt=prompt,
                system="You are a penetration testing expert identifying attack chains.",
                temperature=0.4
            )
            
            response = await self.ai_client.generate(request)
            chains_data = json.loads(response.response)
            
            for chain_data in chains_data:
                chain_vulns = []
                for vuln_id in chain_data.get("vulnerability_ids", []):
                    if vuln_id in self.vulnerabilities:
                        chain_vulns.append(self.vulnerabilities[vuln_id])
                
                if len(chain_vulns) > 1:
                    chains.append(chain_vulns)
            
        except Exception as e:
            logger.error(f"Attack chain identification failed: {e}")
        
        return chains
    
    def _group_similar_vulnerabilities(self) -> Dict[str, List[Vulnerability]]:
        """Group similar vulnerabilities"""
        groups = defaultdict(list)
        
        for vuln in self.vulnerabilities.values():
            # Group by vulnerability name (simplified)
            key = vuln.name.lower().replace(" ", "_")
            groups[key].append(vuln)
        
        # Only return groups with multiple vulnerabilities
        return {k: v for k, v in groups.items() if len(v) > 1}
    
    def _calculate_cluster_risk(self, vulnerabilities: List[Vulnerability]) -> float:
        """Calculate risk score for vulnerability cluster"""
        if not vulnerabilities:
            return 0.0
        
        # Base score from individual vulnerabilities
        severity_scores = {
            SeverityLevel.CRITICAL: 10.0,
            SeverityLevel.HIGH: 7.5,
            SeverityLevel.MEDIUM: 5.0,
            SeverityLevel.LOW: 2.5,
            SeverityLevel.INFO: 1.0
        }
        
        total_score = sum(severity_scores.get(v.severity, 1.0) for v in vulnerabilities)
        
        # Apply multipliers
        multiplier = 1.0
        
        # More vulnerabilities = higher risk
        if len(vulnerabilities) > 3:
            multiplier *= 1.5
        elif len(vulnerabilities) > 1:
            multiplier *= 1.2
        
        # Exploitable vulnerabilities increase risk
        exploitable_count = sum(1 for v in vulnerabilities if v.exploitable)
        if exploitable_count > 0:
            multiplier *= (1.0 + exploitable_count * 0.3)
        
        # Network services increase risk
        network_vulns = sum(1 for v in vulnerabilities if v.vuln_type == VulnerabilityType.NETWORK)
        if network_vulns > 0:
            multiplier *= 1.3
        
        return min(total_score * multiplier, 100.0)  # Cap at 100
    
    def _assess_attack_complexity(self, vulnerabilities: List[Vulnerability]) -> str:
        """Assess attack complexity for vulnerability cluster"""
        if not vulnerabilities:
            return "unknown"
        
        # Count by difficulty
        difficulties = [v.exploit_difficulty for v in vulnerabilities if v.exploitable]
        
        if not difficulties:
            return "high"  # No exploitable vulnerabilities
        
        if "trivial" in difficulties:
            return "trivial"
        elif "easy" in difficulties:
            return "easy"
        elif "medium" in difficulties:
            return "medium"
        else:
            return "hard"
    
    def _check_service_vulnerabilities(self, service: str, version: str, host: str, port: int) -> List[Vulnerability]:
        """Check for known vulnerabilities in service/version"""
        vulnerabilities = []
        
        service_lower = service.lower()
        
        # Known vulnerable services (simplified)
        if "apache" in service_lower:
            if "2.4.49" in version or "2.4.50" in version:
                vuln = Vulnerability(
                    vuln_id="",
                    name="Apache HTTP Server Path Traversal",
                    description="Apache HTTP Server versions 2.4.49 and 2.4.50 are vulnerable to path traversal",
                    severity=SeverityLevel.HIGH,
                    vuln_type=VulnerabilityType.WEB_APPLICATION,
                    host=host,
                    port=port,
                    service=service,
                    cve_ids=["CVE-2021-41773"],
                    tool_source="nmap",
                    exploitable=True,
                    exploit_difficulty="easy"
                )
                vulnerabilities.append(vuln)
        
        elif "openssh" in service_lower:
            if version and any(v in version for v in ["7.4", "7.5", "7.6"]):
                vuln = Vulnerability(
                    vuln_id="",
                    name="OpenSSH User Enumeration",
                    description="OpenSSH versions are vulnerable to user enumeration",
                    severity=SeverityLevel.MEDIUM,
                    vuln_type=VulnerabilityType.NETWORK,
                    host=host,
                    port=port,
                    service=service,
                    tool_source="nmap",
                    exploitable=False,
                    exploit_difficulty="medium"
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _map_nikto_severity(self, nikto_severity: str) -> SeverityLevel:
        """Map Nikto severity to standard severity levels"""
        mapping = {
            "1": SeverityLevel.INFO,
            "2": SeverityLevel.LOW,
            "3": SeverityLevel.MEDIUM,
            "4": SeverityLevel.HIGH,
            "5": SeverityLevel.CRITICAL
        }
        return mapping.get(str(nikto_severity), SeverityLevel.INFO)
    
    def _map_nuclei_severity(self, nuclei_severity: str) -> SeverityLevel:
        """Map Nuclei severity to standard severity levels"""
        mapping = {
            "info": SeverityLevel.INFO,
            "low": SeverityLevel.LOW,
            "medium": SeverityLevel.MEDIUM,
            "high": SeverityLevel.HIGH,
            "critical": SeverityLevel.CRITICAL
        }
        return mapping.get(nuclei_severity.lower(), SeverityLevel.INFO)
    
    def _determine_vuln_type(self, nuclei_match: Dict[str, Any]) -> VulnerabilityType:
        """Determine vulnerability type from Nuclei match"""
        tags = nuclei_match.get("info", {}).get("tags", [])
        
        if any(tag in tags for tag in ["web", "http", "webapp"]):
            return VulnerabilityType.WEB_APPLICATION
        elif any(tag in tags for tag in ["network", "tcp", "udp"]):
            return VulnerabilityType.NETWORK
        elif any(tag in tags for tag in ["database", "sql", "mysql", "postgres"]):
            return VulnerabilityType.DATABASE
        else:
            return VulnerabilityType.SYSTEM
    
    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """Get summary of all vulnerabilities"""
        if not self.vulnerabilities:
            return {"total": 0, "by_severity": {}, "by_type": {}, "clusters": 0}
        
        by_severity = defaultdict(int)
        by_type = defaultdict(int)
        
        for vuln in self.vulnerabilities.values():
            by_severity[vuln.severity.value] += 1
            by_type[vuln.vuln_type.value] += 1
        
        return {
            "total": len(self.vulnerabilities),
            "by_severity": dict(by_severity),
            "by_type": dict(by_type),
            "clusters": len(self.clusters),
            "exploitable": sum(1 for v in self.vulnerabilities.values() if v.exploitable)
        }
    
    def get_top_risks(self, limit: int = 10) -> List[Vulnerability]:
        """Get top risk vulnerabilities"""
        severity_order = {
            SeverityLevel.CRITICAL: 5,
            SeverityLevel.HIGH: 4,
            SeverityLevel.MEDIUM: 3,
            SeverityLevel.LOW: 2,
            SeverityLevel.INFO: 1
        }
        
        sorted_vulns = sorted(
            self.vulnerabilities.values(),
            key=lambda v: (severity_order.get(v.severity, 0), v.exploitable, v.cvss_score or 0),
            reverse=True
        )
        
        return sorted_vulns[:limit]
    
    def get_clusters_by_risk(self) -> List[VulnerabilityCluster]:
        """Get vulnerability clusters sorted by risk"""
        return sorted(self.clusters.values(), key=lambda c: c.risk_score, reverse=True)