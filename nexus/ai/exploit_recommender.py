"""
Nexus Exploit Recommendation System

AI-powered exploit recommendation engine that analyzes vulnerabilities,
suggests appropriate exploits, and provides detailed exploitation guidance
with safety considerations and success probability assessments.
"""

import json
import re
import time
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import logging
import requests
from pathlib import Path

from .vulnerability_correlator import Vulnerability, SeverityLevel, VulnerabilityType

logger = logging.getLogger(__name__)


class ExploitType(Enum):
    """Types of exploits"""
    REMOTE_CODE_EXECUTION = "remote_code_execution"
    LOCAL_PRIVILEGE_ESCALATION = "local_privilege_escalation"
    SQL_INJECTION = "sql_injection"
    CROSS_SITE_SCRIPTING = "cross_site_scripting"
    BUFFER_OVERFLOW = "buffer_overflow"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    INFORMATION_DISCLOSURE = "information_disclosure"
    DENIAL_OF_SERVICE = "denial_of_service"
    FILE_INCLUSION = "file_inclusion"
    COMMAND_INJECTION = "command_injection"


class ExploitComplexity(Enum):
    """Exploit complexity levels"""
    TRIVIAL = "trivial"      # Point and click
    EASY = "easy"            # Minimal configuration needed
    MEDIUM = "medium"        # Some technical knowledge required
    HARD = "hard"            # Advanced technical skills required
    EXPERT = "expert"        # Exploit development skills required


@dataclass
class ExploitRecommendation:
    """Individual exploit recommendation"""
    exploit_id: str
    name: str
    description: str
    exploit_type: ExploitType
    complexity: ExploitComplexity
    success_probability: float  # 0.0 to 1.0
    stealth_rating: float      # 0.0 to 1.0 (higher = more stealthy)
    target_vulnerability: Vulnerability
    
    # Exploit details
    cve_ids: List[str] = field(default_factory=list)
    exploit_db_id: Optional[str] = None
    metasploit_module: Optional[str] = None
    nuclei_template: Optional[str] = None
    custom_script: Optional[str] = None
    
    # Requirements and prerequisites
    requirements: List[str] = field(default_factory=list)
    prerequisites: List[str] = field(default_factory=list)
    target_os: List[str] = field(default_factory=list)
    target_versions: List[str] = field(default_factory=list)
    
    # Execution details
    payload_options: Dict[str, Any] = field(default_factory=dict)
    execution_steps: List[str] = field(default_factory=list)
    verification_steps: List[str] = field(default_factory=list)
    
    # Risk assessment
    detection_risk: str = "medium"  # low, medium, high
    impact_assessment: str = ""
    cleanup_required: bool = False
    cleanup_steps: List[str] = field(default_factory=list)
    
    # Additional metadata
    references: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    created_at: float = field(default_factory=time.time)


class ExploitDatabase:
    """Exploit database interface"""
    
    def __init__(self):
        self.exploits = {}
        self.load_exploit_database()
    
    def load_exploit_database(self):
        """Load exploit database from various sources"""
        
        # Load Metasploit modules
        self._load_metasploit_modules()
        
        # Load Exploit-DB entries
        self._load_exploitdb_entries()
        
        # Load custom exploits
        self._load_custom_exploits()
        
        logger.info(f"Loaded {len(self.exploits)} exploits into database")
    
    def _load_metasploit_modules(self):
        """Load Metasploit module information"""
        
        # Sample Metasploit modules (in real implementation, parse from MSF)
        metasploit_modules = {
            "exploit/multi/http/apache_normalize_path_rce": {
                "name": "Apache HTTP Server 2.4.49 Path Traversal RCE",
                "description": "Apache HTTP Server 2.4.49 path traversal and RCE",
                "type": ExploitType.REMOTE_CODE_EXECUTION,
                "complexity": ExploitComplexity.EASY,
                "cve_ids": ["CVE-2021-41773", "CVE-2021-42013"],
                "target_service": "apache",
                "target_versions": ["2.4.49", "2.4.50"],
                "success_rate": 0.85,
                "stealth_rating": 0.6
            },
            "exploit/linux/ssh/ssh_login": {
                "name": "SSH Login Scanner",
                "description": "SSH brute force login scanner",
                "type": ExploitType.AUTHENTICATION_BYPASS,
                "complexity": ExploitComplexity.EASY,
                "target_service": "ssh",
                "success_rate": 0.3,
                "stealth_rating": 0.2
            },
            "exploit/windows/smb/ms17_010_eternalblue": {
                "name": "MS17-010 EternalBlue SMB RCE",
                "description": "Windows SMB EternalBlue exploit",
                "type": ExploitType.REMOTE_CODE_EXECUTION,
                "complexity": ExploitComplexity.MEDIUM,
                "cve_ids": ["CVE-2017-0144"],
                "target_service": "smb",
                "success_rate": 0.9,
                "stealth_rating": 0.3
            }
        }
        
        for module_path, module_info in metasploit_modules.items():
            self.exploits[module_path] = module_info
    
    def _load_exploitdb_entries(self):
        """Load Exploit-DB entries"""
        
        # Sample Exploit-DB entries
        exploitdb_entries = {
            "50383": {
                "name": "Apache HTTP Server 2.4.50 - Path Traversal RCE",
                "description": "Remote code execution via path traversal",
                "type": ExploitType.REMOTE_CODE_EXECUTION,
                "complexity": ExploitComplexity.MEDIUM,
                "cve_ids": ["CVE-2021-42013"],
                "target_service": "apache",
                "success_rate": 0.8,
                "stealth_rating": 0.5
            },
            "49908": {
                "name": "WordPress Plugin WP Statistics 13.0.8 - SQL Injection",
                "description": "SQL injection in WP Statistics plugin",
                "type": ExploitType.SQL_INJECTION,
                "complexity": ExploitComplexity.EASY,
                "target_service": "wordpress",
                "success_rate": 0.9,
                "stealth_rating": 0.7
            }
        }
        
        for edb_id, exploit_info in exploitdb_entries.items():
            exploit_key = f"exploitdb_{edb_id}"
            self.exploits[exploit_key] = exploit_info
    
    def _load_custom_exploits(self):
        """Load custom exploit definitions"""
        
        custom_exploits = {
            "custom_sql_injection_basic": {
                "name": "Basic SQL Injection Exploit",
                "description": "Generic SQL injection exploitation",
                "type": ExploitType.SQL_INJECTION,
                "complexity": ExploitComplexity.EASY,
                "target_service": "web",
                "success_rate": 0.7,
                "stealth_rating": 0.8
            },
            "custom_xss_reflected": {
                "name": "Reflected XSS Exploit",
                "description": "Reflected cross-site scripting exploitation",
                "type": ExploitType.CROSS_SITE_SCRIPTING,
                "complexity": ExploitComplexity.EASY,
                "target_service": "web",
                "success_rate": 0.9,
                "stealth_rating": 0.9
            }
        }
        
        for exploit_id, exploit_info in custom_exploits.items():
            self.exploits[exploit_id] = exploit_info
    
    def search_exploits(self, service: str = None, cve_id: str = None, 
                       exploit_type: ExploitType = None) -> List[Dict[str, Any]]:
        """Search for exploits matching criteria"""
        
        results = []
        
        for exploit_id, exploit_info in self.exploits.items():
            match = True
            
            if service and exploit_info.get("target_service", "").lower() != service.lower():
                match = False
            
            if cve_id and cve_id not in exploit_info.get("cve_ids", []):
                match = False
            
            if exploit_type and exploit_info.get("type") != exploit_type:
                match = False
            
            if match:
                result = exploit_info.copy()
                result["exploit_id"] = exploit_id
                results.append(result)
        
        return results


class ExploitRecommender:
    """AI-powered exploit recommendation engine"""
    
    def __init__(self, ai_client, config):
        self.ai_client = ai_client
        self.config = config
        self.exploit_db = ExploitDatabase()
        self.recommendation_cache = {}
    
    async def recommend_exploits(self, vulnerability: Vulnerability, 
                               context: Dict[str, Any] = None) -> List[ExploitRecommendation]:
        """Recommend exploits for a given vulnerability"""
        
        context = context or {}
        
        # Check cache first
        cache_key = f"{vulnerability.vuln_id}_{hash(str(context))}"
        if cache_key in self.recommendation_cache:
            return self.recommendation_cache[cache_key]
        
        recommendations = []
        
        # 1. Search exploit database for direct matches
        db_matches = self._search_exploit_database(vulnerability)
        
        # 2. Use AI to analyze vulnerability and suggest exploits
        ai_recommendations = await self._ai_recommend_exploits(vulnerability, context)
        
        # 3. Combine and rank recommendations
        all_recommendations = db_matches + ai_recommendations
        ranked_recommendations = self._rank_recommendations(all_recommendations, vulnerability, context)
        
        # 4. Generate detailed exploit recommendations
        for rec_data in ranked_recommendations[:10]:  # Top 10 recommendations
            recommendation = await self._create_exploit_recommendation(rec_data, vulnerability, context)
            if recommendation:
                recommendations.append(recommendation)
        
        # Cache results
        self.recommendation_cache[cache_key] = recommendations
        
        logger.info(f"Generated {len(recommendations)} exploit recommendations for {vulnerability.name}")
        return recommendations
    
    def _search_exploit_database(self, vulnerability: Vulnerability) -> List[Dict[str, Any]]:
        """Search exploit database for matching exploits"""
        
        matches = []
        
        # Search by CVE IDs
        for cve_id in vulnerability.cve_ids:
            cve_matches = self.exploit_db.search_exploits(cve_id=cve_id)
            matches.extend(cve_matches)
        
        # Search by service
        if vulnerability.service:
            service_matches = self.exploit_db.search_exploits(service=vulnerability.service)
            matches.extend(service_matches)
        
        # Search by vulnerability type
        vuln_type_mapping = {
            VulnerabilityType.WEB_APPLICATION: [ExploitType.SQL_INJECTION, ExploitType.CROSS_SITE_SCRIPTING],
            VulnerabilityType.NETWORK: [ExploitType.REMOTE_CODE_EXECUTION, ExploitType.BUFFER_OVERFLOW],
            VulnerabilityType.SYSTEM: [ExploitType.LOCAL_PRIVILEGE_ESCALATION]
        }
        
        for exploit_type in vuln_type_mapping.get(vulnerability.vuln_type, []):
            type_matches = self.exploit_db.search_exploits(exploit_type=exploit_type)
            matches.extend(type_matches)
        
        # Remove duplicates
        unique_matches = []
        seen_ids = set()
        for match in matches:
            if match["exploit_id"] not in seen_ids:
                unique_matches.append(match)
                seen_ids.add(match["exploit_id"])
        
        return unique_matches
    
    async def _ai_recommend_exploits(self, vulnerability: Vulnerability, 
                                   context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Use AI to recommend exploits for vulnerability"""
        
        prompt = f"""Analyze this vulnerability and recommend appropriate exploits:

VULNERABILITY:
- Name: {vulnerability.name}
- Description: {vulnerability.description}
- Type: {vulnerability.vuln_type.value}
- Severity: {vulnerability.severity.value}
- Host: {vulnerability.host}
- Port: {vulnerability.port}
- Service: {vulnerability.service}
- CVE IDs: {vulnerability.cve_ids}
- Exploitable: {vulnerability.exploitable}

CONTEXT:
{json.dumps(context, indent=2)}

Recommend exploits that could be used against this vulnerability. Consider:
1. Direct exploits targeting the specific vulnerability
2. Generic exploits for the service/application
3. Chained exploits that could leverage this vulnerability
4. Post-exploitation techniques if this provides initial access

Return as JSON array:
[
  {{
    "name": "exploit name",
    "description": "detailed description",
    "type": "remote_code_execution|sql_injection|xss|etc",
    "complexity": "trivial|easy|medium|hard|expert",
    "success_probability": 0.0-1.0,
    "stealth_rating": 0.0-1.0,
    "requirements": ["requirement1", "requirement2"],
    "execution_steps": ["step1", "step2", "step3"],
    "detection_risk": "low|medium|high",
    "metasploit_module": "module/path or null",
    "custom_command": "command to execute or null"
  }}
]

Only return valid JSON."""

        try:
            from nexus.ai.ollama_client import GenerationRequest
            request = GenerationRequest(
                model=self.config.ai.model,
                prompt=prompt,
                system="You are an expert penetration tester with deep knowledge of exploits and attack techniques.",
                temperature=0.4
            )
            
            response = await self.ai_client.generate(request)
            recommendations = json.loads(response.response)
            
            # Add exploit_id to each recommendation
            for i, rec in enumerate(recommendations):
                rec["exploit_id"] = f"ai_recommendation_{vulnerability.vuln_id}_{i}"
                rec["source"] = "ai_generated"
            
            return recommendations
            
        except Exception as e:
            logger.error(f"AI exploit recommendation failed: {e}")
            return []
    
    def _rank_recommendations(self, recommendations: List[Dict[str, Any]], 
                            vulnerability: Vulnerability, context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Rank exploit recommendations by suitability"""
        
        def calculate_score(rec: Dict[str, Any]) -> float:
            score = 0.0
            
            # Base score from success probability
            score += rec.get("success_probability", rec.get("success_rate", 0.5)) * 40
            
            # Bonus for exact CVE matches
            if any(cve in vulnerability.cve_ids for cve in rec.get("cve_ids", [])):
                score += 30
            
            # Bonus for service matches
            if vulnerability.service and rec.get("target_service") == vulnerability.service.lower():
                score += 20
            
            # Penalty for high complexity
            complexity_penalties = {
                "trivial": 0,
                "easy": -2,
                "medium": -5,
                "hard": -10,
                "expert": -15
            }
            score += complexity_penalties.get(rec.get("complexity", "medium"), -5)
            
            # Bonus for stealth
            stealth_rating = rec.get("stealth_rating", 0.5)
            score += stealth_rating * 10
            
            # Context-based adjustments
            if context.get("stealth_required", False):
                score += stealth_rating * 20
            
            if context.get("quick_wins_preferred", False):
                if rec.get("complexity") in ["trivial", "easy"]:
                    score += 15
            
            return score
        
        # Sort by calculated score
        ranked = sorted(recommendations, key=calculate_score, reverse=True)
        
        return ranked
    
    async def _create_exploit_recommendation(self, rec_data: Dict[str, Any], 
                                           vulnerability: Vulnerability, 
                                           context: Dict[str, Any]) -> Optional[ExploitRecommendation]:
        """Create detailed exploit recommendation"""
        
        try:
            # Map string values to enums
            exploit_type = ExploitType(rec_data.get("type", "remote_code_execution"))
            complexity = ExploitComplexity(rec_data.get("complexity", "medium"))
            
            # Generate detailed execution steps if not provided
            execution_steps = rec_data.get("execution_steps", [])
            if not execution_steps:
                execution_steps = await self._generate_execution_steps(rec_data, vulnerability)
            
            # Generate verification steps
            verification_steps = await self._generate_verification_steps(rec_data, vulnerability)
            
            # Assess payload options
            payload_options = await self._generate_payload_options(rec_data, vulnerability, context)
            
            recommendation = ExploitRecommendation(
                exploit_id=rec_data["exploit_id"],
                name=rec_data["name"],
                description=rec_data["description"],
                exploit_type=exploit_type,
                complexity=complexity,
                success_probability=rec_data.get("success_probability", rec_data.get("success_rate", 0.5)),
                stealth_rating=rec_data.get("stealth_rating", 0.5),
                target_vulnerability=vulnerability,
                cve_ids=rec_data.get("cve_ids", []),
                metasploit_module=rec_data.get("metasploit_module"),
                requirements=rec_data.get("requirements", []),
                execution_steps=execution_steps,
                verification_steps=verification_steps,
                payload_options=payload_options,
                detection_risk=rec_data.get("detection_risk", "medium")
            )
            
            return recommendation
            
        except Exception as e:
            logger.error(f"Failed to create exploit recommendation: {e}")
            return None
    
    async def _generate_execution_steps(self, rec_data: Dict[str, Any], 
                                      vulnerability: Vulnerability) -> List[str]:
        """Generate detailed execution steps for exploit"""
        
        if rec_data.get("metasploit_module"):
            return [
                f"Start Metasploit: msfconsole",
                f"Use module: use {rec_data['metasploit_module']}",
                f"Set target: set RHOSTS {vulnerability.host}",
                f"Set port: set RPORT {vulnerability.port}" if vulnerability.port else "# Port auto-detected",
                "Show options: show options",
                "Execute: exploit"
            ]
        elif rec_data.get("custom_command"):
            return [
                f"Execute command: {rec_data['custom_command']}",
                "Monitor output for success indicators",
                "Verify exploitation success"
            ]
        else:
            # Generate generic steps based on exploit type
            exploit_type = rec_data.get("type", "")
            
            if "sql_injection" in exploit_type:
                return [
                    "Identify injection point",
                    "Test for SQL injection vulnerability",
                    "Enumerate database structure",
                    "Extract sensitive data",
                    "Attempt privilege escalation if possible"
                ]
            elif "xss" in exploit_type:
                return [
                    "Identify XSS injection point",
                    "Craft malicious payload",
                    "Test payload execution",
                    "Set up listener for callbacks",
                    "Execute social engineering attack"
                ]
            else:
                return [
                    "Prepare exploit environment",
                    "Configure exploit parameters",
                    "Execute exploit against target",
                    "Verify successful exploitation",
                    "Establish persistent access if needed"
                ]
    
    async def _generate_verification_steps(self, rec_data: Dict[str, Any], 
                                         vulnerability: Vulnerability) -> List[str]:
        """Generate verification steps for exploit success"""
        
        exploit_type = rec_data.get("type", "")
        
        if "remote_code_execution" in exploit_type:
            return [
                "Check for command shell or meterpreter session",
                "Execute 'whoami' to verify user context",
                "Check network connectivity: ping attacker IP",
                "Verify file system access: ls / or dir C:\\",
                "Test privilege level: id or whoami /priv"
            ]
        elif "sql_injection" in exploit_type:
            return [
                "Verify database access with SELECT statement",
                "Check current database user privileges",
                "Test data extraction capabilities",
                "Verify ability to read/write files if applicable"
            ]
        elif "authentication_bypass" in exploit_type:
            return [
                "Confirm successful authentication bypass",
                "Access restricted functionality",
                "Verify elevated privileges if applicable",
                "Test persistence of access"
            ]
        else:
            return [
                "Verify exploit execution completed successfully",
                "Check for expected changes in target system",
                "Confirm access to target resources",
                "Test stability of compromised access"
            ]
    
    async def _generate_payload_options(self, rec_data: Dict[str, Any], 
                                      vulnerability: Vulnerability, 
                                      context: Dict[str, Any]) -> Dict[str, Any]:
        """Generate payload configuration options"""
        
        options = {}
        
        # Common payload options
        if context.get("attacker_ip"):
            options["LHOST"] = context["attacker_ip"]
        
        if context.get("callback_port"):
            options["LPORT"] = context["callback_port"]
        else:
            options["LPORT"] = 4444  # Default
        
        # Target-specific options
        options["RHOSTS"] = vulnerability.host
        if vulnerability.port:
            options["RPORT"] = vulnerability.port
        
        # Exploit-specific options
        exploit_type = rec_data.get("type", "")
        
        if "sql_injection" in exploit_type:
            options.update({
                "TECHNIQUE": "BEUSTQ",
                "RISK": 1,
                "LEVEL": 1,
                "THREADS": 1
            })
        elif "buffer_overflow" in exploit_type:
            options.update({
                "PAYLOAD": "generic/shell_reverse_tcp",
                "EXITFUNC": "thread"
            })
        
        return options
    
    async def generate_exploit_script(self, recommendation: ExploitRecommendation, 
                                    context: Dict[str, Any] = None) -> Optional[str]:
        """Generate custom exploit script based on recommendation"""
        
        context = context or {}
        
        prompt = f"""Generate a custom exploit script based on this recommendation:

EXPLOIT RECOMMENDATION:
- Name: {recommendation.name}
- Type: {recommendation.exploit_type.value}
- Target: {recommendation.target_vulnerability.host}:{recommendation.target_vulnerability.port}
- Service: {recommendation.target_vulnerability.service}
- Vulnerability: {recommendation.target_vulnerability.name}

EXECUTION STEPS:
{chr(10).join(f"- {step}" for step in recommendation.execution_steps)}

PAYLOAD OPTIONS:
{json.dumps(recommendation.payload_options, indent=2)}

CONTEXT:
{json.dumps(context, indent=2)}

Generate a complete, executable script that implements this exploit.
Choose the most appropriate language (Python, Bash, PowerShell, etc.).
Include proper error handling, logging, and safety checks.
Add comments explaining each step.

Return only the script code, no additional explanation."""

        try:
            from nexus.ai.ollama_client import GenerationRequest
            request = GenerationRequest(
                model=self.config.ai.model,
                prompt=prompt,
                system="You are an expert exploit developer creating safe, educational exploit scripts.",
                temperature=0.3
            )
            
            response = await self.ai_client.generate(request)
            return response.response.strip()
            
        except Exception as e:
            logger.error(f"Exploit script generation failed: {e}")
            return None
    
    def get_recommendations_by_severity(self, recommendations: List[ExploitRecommendation]) -> Dict[str, List[ExploitRecommendation]]:
        """Group recommendations by target vulnerability severity"""
        
        groups = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": [],
            "info": []
        }
        
        for rec in recommendations:
            severity = rec.target_vulnerability.severity.value
            groups[severity].append(rec)
        
        return groups
    
    def get_recommendations_by_complexity(self, recommendations: List[ExploitRecommendation]) -> Dict[str, List[ExploitRecommendation]]:
        """Group recommendations by exploit complexity"""
        
        groups = {
            "trivial": [],
            "easy": [],
            "medium": [],
            "hard": [],
            "expert": []
        }
        
        for rec in recommendations:
            complexity = rec.complexity.value
            groups[complexity].append(rec)
        
        return groups